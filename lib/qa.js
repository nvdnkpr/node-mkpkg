// Generated by CoffeeScript 1.6.3
var QA, bold, pad, rl;

rl = require('readline');

pad = require('pad');

require('./set_prompt');

bold = function(text) {
  return "\x1b[1m" + text + "\x1b[22m";
};

/*
QA, Questions & Answers
=======================
A small framework to ask question and retrieve answers.

Usage:
`ask(questions, [options], callback)`
`ask([questions], options, callback)`

Options include
*   `questions`     Array of questions when not provided as a separate argument, required in such case.
*   `interface`     Readline interface, optional.
*   `input`         The readable stream to listen to, used to initialize the readline interface unless provided, default to `process.stdin`.
*   `output`        The writable stream to listen to, used to initialize the readline interface unless provided, default to `process.stdout`.
*   `completer`     Optional function that is used for Tab autocompletion, used to initialize the readline interface unless provided.
*/


QA = function(questions, options, callback) {
  var question, _i, _len, _ref,
    _this = this;
  if (arguments.length === 3) {
    options.questions = questions;
  } else if (arguments.length === 2) {
    callback = options;
    if (Array.isArray(questions)) {
      options = {
        questions: questions
      };
    } else {
      options = questions;
    }
  } else {
    return callback(new Error('Invalid arguments'));
  }
  if (options.questions == null) {
    return callback(new Error('No question asked'));
  }
  this.callback = callback;
  if (options.input == null) {
    options.input = process.stdin;
  }
  if (options.output == null) {
    options.output = process.stdout;
  }
  if (options.completer == null) {
    options.completer = null;
  }
  if (options.terminal == null) {
    options.terminal = !!options.output.isTTY;
  }
  options.close_interface = !options["interface"];
  if (options["interface"] == null) {
    options["interface"] = rl.createInterface(options.input, options.output, options.completer, options.terminal);
  }
  if (options.yes == null) {
    options.yes = ['yes'];
  }
  if (!Array.isArray(options.yes)) {
    if (options.yes == null) {
      options.yes = [options.yes];
    }
  }
  if (options.no == null) {
    options.no = ['no'];
  }
  if (!Array.isArray(options.no)) {
    if (options.yes == null) {
      options.yes = [options.no];
    }
  }
  if (options.index == null) {
    options.index = 0;
  }
  if (options.max_index == null) {
    options.max_index = options.index;
  }
  _ref = options.questions;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    question = _ref[_i];
    options.questions[question.name] = question;
    if (question.label == null) {
      question.label = question.name;
    }
  }
  this.options = options;
  this.answers = {};
  return process.nextTick(function() {
    return _this.ask();
  });
};

QA.prototype.disable = function() {
  return this.disabled = true;
};

QA.prototype.end = function(i) {
  var _this = this;
  if (this.options.close_interface) {
    this.options["interface"].close();
    return this.options["interface"].on('close', function() {
      return _this.callback(null, _this.answers);
    });
  } else {
    return this.callback(null, this.answers);
  }
};

QA.prototype.ask = function(i) {
  var ask,
    _this = this;
  this.disabled = false;
  ask = function() {
    var answers, dft, label, n, nif, pos, q, question, val, y, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (_this.disabled) {
      return;
    }
    if (i != null) {
      _this.options.index = i;
    }
    question = _this.options.questions[_this.options.index];
    if (!question) {
      return _this.end();
    }
    if (question["if"] != null) {
      nif = question["if"];
      if (typeof nif === 'function') {
        answers = {};
        _ref = _this.options.questions;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          q = _ref[_i];
          answers[q.name] = q.value;
        }
        nif = nif(answers);
      }
      if (!nif) {
        _this.options.index++;
        return ask();
      }
    }
    pos = "" + (_this.options.index + 1) + ".";
    label = "" + (pad(pos, 3)) + " " + question.label;
    if (question["default"]) {
      dft = question["default"];
      if (typeof question["default"] === 'function') {
        answers = {};
        _ref1 = _this.options.questions;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          q = _ref1[_j];
          answers[q.name] = q.value;
        }
        dft = question["default"](answers);
      }
    }
    if (question.type === 'boolean') {
      if (dft != null) {
        y = dft ? bold(_this.options.yes) : _this.options.yes;
        n = !dft ? bold(_this.options.no) : _this.options.no;
        label += "[" + y + "," + n + "]";
      }
    } else if (question.values) {
      label += ' [';
      _ref2 = question.values;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        val = _ref2[i];
        if (dft === val) {
          val = bold(val);
        }
        label += val;
        if (i + 1 !== question.values.length) {
          label += ',';
        }
      }
      label += ']';
    } else if (dft) {
      label += " [" + dft + "]";
    }
    if (!question.required && !question["default"]) {
      label += " [optional]";
    }
    label += ': ';
    return _this.options["interface"].question(label, function(answer) {
      var m, valid, _l, _len3, _ref3;
      if (!question.no_trim) {
        answer = answer.trim();
      }
      if (answer === '' && question["default"]) {
        answer = dft;
      }
      if (answer === '' && question.required) {
        _this.options["interface"].write(_this.options.required);
        rl.moveCursor(_this.options["interface"].output, label.length - _this.options.required.length, -1);
        setTimeout(function() {
          rl.moveCursor(_this.options["interface"].output, 0, 1);
          _this.options["interface"]._deleteLineLeft();
          rl.moveCursor(_this.options["interface"].output, 0, -1);
          _this.options["interface"]._deleteLineRight();
          return ask();
        }, _this.options.wait);
        return;
      }
      if (question.match) {
        valid = false;
        _ref3 = question.match;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          m = _ref3[_l];
          if (m.exec(answer)) {
            valid = true;
          }
        }
        if (!valid) {
          _this.options["interface"].write(_this.options.invalid);
          rl.moveCursor(_this.options["interface"].output, label.length - _this.options.required.length, -1);
          setTimeout(function() {
            rl.moveCursor(this.options["interface"].output, 0, 1);
            this.options["interface"]._deleteLineLeft();
            rl.moveCursor(this.options["interface"].output, 0, -1);
            this.options["interface"]._deleteLineRight();
            return ask();
          }, _this.options.wait);
        }
        return;
      }
      if (question.type === 'boolean' && typeof answer !== 'boolean') {
        answer = answer.toLowerCase();
        switch (false) {
          case _this.options.yes.indexOf(answer) === -1:
            answer = true;
            break;
          case _this.options.no.indexOf(answer) === -1:
            answer = false;
            break;
          default:
            return ask();
        }
      }
      question.value = answer;
      _this.answers[question.name] = answer;
      _this.options.index++;
      _this.options.max_index = Math.max(_this.options.max_index, _this.options.index);
      return ask();
    });
  };
  return ask();
};

module.exports = function(config, callback) {
  return new QA(config, callback);
};

module.exports.QA = QA;
