// Generated by CoffeeScript 1.6.3
var EventEmitter, Git, bold, dft_options, fs, mkpkg, qa, rl, util;

EventEmitter = require('events').EventEmitter;

fs = require('fs');

rl = require('readline');

util = require('util');

Git = require('git/lib/git').Git;

qa = require('./qa');

dft_options = require('./options');

require('./set_prompt');

bold = function(text) {
  return "\x1b[1m" + text + "\x1b[22m";
};

mkpkg = function(options) {
  var k, rli, v,
    _this = this;
  if (options == null) {
    options = {};
  }
  for (k in dft_options) {
    v = dft_options[k];
    if (options[k] == null) {
      options[k] = v;
    }
  }
  EventEmitter.call(this, options);
  rli = options["interface"] = rl.createInterface(options.input, options.output, options.completer, options.terminal);
  options.input.on('keypress', function(s, key) {
    if ((key != null ? key.name : void 0) === 'escape') {
      options["interface"]._questionCallback = null;
      if (_this.questions) {
        _this.questions.disable();
      }
      return _this.help();
    } else if ((key != null ? key.name : void 0) === 'down') {
      options.index++;
      return _this.create();
    } else if ((key != null ? key.name : void 0) === 'up') {
      if (options.index) {
        options.index--;
      }
      return _this.create();
    }
  });
  this.intro = function() {
    options["interface"].write(options.intro);
    options["interface"].write('\n');
    return _this[options.action]();
  };
  this.quit = function() {
    _this.emit('quit');
    if (options.exit) {
      _this.emit('exit');
      return process.exit();
    }
  };
  this.error = function(msg, exit) {
    options["interface"].write(msg);
    if (exit === true) {
      exit = 1;
    }
    if (exit) {
      return _this.quit(exit);
    }
  };
  this.help = function() {
    options["interface"].write("\n" + options.commands + "\n");
    return options["interface"].question('', function(answer) {
      switch (answer) {
        case 'quit':
        case 'q':
          return _this.quit();
        case 'load':
        case 'l':
          return _this.load();
        case 'reset':
        case 'r':
          return _this.reset();
        case 'save':
        case 's':
          return _this.save();
        case 'view':
        case 'v':
          return _this.view();
        case 'create':
        case 'c':
        case '':
          return _this.create();
        default:
          return _this.error('Invalid command');
      }
    });
  };
  this.view = function() {
    var i, question, _i, _len, _ref, _results;
    _ref = options.questions;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      question = _ref[i];
      if (i === options.max_index) {
        break;
      }
      _results.push(options["interface"].write("" + question.name + ": " + question.value + "\n"));
    }
    return _results;
  };
  this.create = function() {
    var generate;
    if (!_this.questions) {
      _this.questions = qa(options, function(err, answers) {
        return generate(answers);
      });
    } else {
      _this.questions.ask();
    }
    return generate = function(answers) {
      var check, dest, finish, git, gitignore, layout, mkdir, packagedotjson;
      return console.log(answers);
      dest = options.questions.location.value;
      check = function() {
        return fs.stat(dest, function(err, stat) {
          if (err) {
            return mkdir();
          }
          return options["interface"].question("Do you wish to overwrite the directory [" + (bold('yes')) + ",no]", function(answer) {
            switch (answer) {
              case 'yes':
              case 'y':
              case '':
                return git();
              default:
                return save();
            }
          });
        });
      };
      mkdir = function() {
        dest = options.questions.location.value;
        return fs.mkdir(dest, function(err) {
          if (err) {
            return error(err, true);
          }
          return git();
        });
      };
      git = function() {
        return fs.exists("" + dest + "/.git", function(exists) {
          if (exists) {
            return gitignore();
          }
          git = new Git(dest);
          return git.init({}, function(err, git) {
            return gitignore();
          });
        });
      };
      gitignore = function() {
        var content;
        content = ".*\n/node_modules\n!.travis.yml\n!.gitignore";
        return fs.writeFile("" + dest + "/.gitignore", content, function(err) {
          return finish();
        });
      };
      layout = function() {
        var lib, src, test;
        lib = function() {
          return fs.mkdir("" + dest + "/lib", function(err) {
            return src();
          });
        };
        src = function() {};
        return test()(!options.questions.coffeescript.value ? fs.mkdir("" + dest + "/src", function(err) {
          return test();
        }) : void 0);
        test = function() {
          return fs.mkdir("" + dest + "/test", function(err) {
            return packagedotjson();
          });
        };
        return lib();
      };
      packagedotjson = function() {
        var content, dep, dependencies, devDependencies, match, optional_dependencies, project, username, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        dest = "" + options.questions.location.value + "/package.json";
        content = {};
        content.name = options.questions.name.value;
        if (options.questions.github) {
          if (match = /\w+@github.com:(.*)\/(.*)\.git/) {
            username = match[1];
            project = match[2];
          } else if (match = /\w+:\/\/github.com\/(.*)\/(.*)\.git/) {
            username = match[1];
            project = match[2];
          }
          content.repository = {
            type: 'git',
            url: options.questions.github.value
          };
        }
        content.dependencies = {};
        dependencies = options.questions.dependencies.value;
        if (dependencies !== '') {
          _ref = options.questions.dependencies.value.split(',');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            dep = _ref[_i];
            content.dependencies[dep] = 'latest';
          }
        }
        content.devDependencies = {};
        devDependencies = options.questions.devDependencies.value;
        if (devDependencies !== '') {
          _ref1 = options.questions.devDependencies.value.split(',');
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            dep = _ref1[_j];
            content.devDependencies[dep] = 'latest';
          }
        }
        content.optionalDependencies = {};
        optional_dependencies = options.questions.optionalDependencies.value;
        if (optional_dependencies !== '') {
          _ref2 = options.questions.optionalDependencies.value.split(',');
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            dep = _ref2[_k];
            content.optionalDependencies[dep] = 'latest';
          }
        }
        content = JSON.stringify(content, null, 4);
        return fs.writeFile(dest, content, 'utf8', function(err) {
          if (err) {
            return error(err, true);
          }
          return git();
        });
      };
      finish = function() {
        return _this.quit();
      };
      return check();
    };
  };
  this.load = function() {
    var ask, enoent, read;
    ask = function() {
      return options["interface"].question('Where is the project file? ', function(answer) {
        answer = answer.trim();
        if (answer === '') {
          return ask();
        }
        return read(answer);
      });
    };
    read = function(src) {
      return fs.readFile(src, function(err, content) {
        var old_options;
        if (err && err.code === 'ENOENT') {
          return enoent();
        }
        if (err) {
          return _this.error(err);
        }
        old_options = options;
        options = JSON.parse(content);
        for (k in old_options) {
          v = old_options[k];
          if (options[k] == null) {
            options[k] = v;
          }
        }
        _this.questions = null;
        return _this.intro();
      });
    };
    enoent = function() {
      options["interface"].write("" + options.enoent + "\n");
      return ask();
    };
    return ask();
  };
  this.reset = function() {
    var question, _i, _len, _ref;
    _ref = options.questions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      question = _ref[_i];
      delete question.value;
    }
    options.index = 0;
    return _this.create();
  };
  this.error = function(err) {
    process.stderr.write("Sorry, an unexpected error occured.\nPlease fill a bug report https://github.com/wdavidw/node-csv-parser/issues.\nAbout to exit.\n");
    return _this.emit('error', err);
  };
  this.save = function() {
    var where, write;
    where = function() {
      return options["interface"].question(options.save_where, function(answer) {
        return save(answer);
      });
    };
    write = function(dest) {
      var content;
      content = JSON.stringify(options);
      return fs.writeFile(dest, content, function(err) {
        return options["interface"].write("" + options.save_successfull + ".\n");
      });
    };
    return _this.view();
  };
  process.nextTick(function() {
    if (options.intro) {
      return _this.intro();
    } else {
      return _this[options.action]();
    }
  });
  return this;
};

util.inherits(mkpkg, EventEmitter);

module.exports = function(options) {
  return new mkpkg(options);
};
